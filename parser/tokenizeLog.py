#!/usr/bin/env python

# Copyright (c) 2009, Regents of the University of California
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following
# disclaimer in the documentation and/or other materials provided
# with the distribution.
#
# * Neither the name of the University of California, Los Angeles
# nor the names of its contributors may be used to endorse or
# promote products derived from this software without specific prior
# written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Author: Roy Shea

from optparse import OptionParser
import rlisTokens
import packet
import packetTrace
import chunkStream
import parseLog


def serialize_tokens(node_id, tokens):
    """Generate a list of token strings describing the call tree."""

    up = "-1"
    reset = "-2"
    out_items = []

    for token in tokens:

        if not token:
            out_items.append(reset)
            continue
        elif type(token) == tuple:
            # TODO: Badness to deal with possible tuple generated by
            # the watch token type.
            data = token[1]
            token = token[0]

        if token.type == rlisTokens.RlisEntry.FOOTER:
            out_items.append(up)

        elif token.type == rlisTokens.RlisEntry.HEADER:
            out_items.append(token.function_name)

        elif token.type == rlisTokens.RlisEntry.CALL:
            out_items.append(token.target)

        elif token.type == rlisTokens.RlisEntry.CONDITIONAL:
            out_items.append("%s_branch_%d" % (token.function_name, token.id))
            out_items.append(up)

        elif token.type == rlisTokens.RlisEntry.WATCH:
            out_items.append("%s_data_%d" % (token.function_name, data))
            out_items.append(up)

        else:
            assert False, "Unexpected token type"

    return out_items


def print_tokens(node_id, tokens):
    """Print the complete contents of each token in a set of tokens."""

    out_stream = ""
    out_stream += "# ==== Trace for node %d ====\n" % (node_id)
    for token in tokens:
        out_stream += str(token) + "\n"


def main():

    # Handle the command line
    usage = "usage: %prog [options] rlis trace"
    parser = OptionParser(usage)

    parser.add_option("-m", "--mode", dest="mode", metavar="STRING",
            default="system", help="Specify the trace mode that " +
            "may be either network or system [default: %default]")

    parser.add_option("-n", "--node", dest="node_id", default=None,
            type="int", help="Only print trace for node with specified " +
            "identifier [default: all nodes]")

    parser.add_option("-v", "--verbose", action="store_true",
            dest="verbose", help="Print full token data rather than " +
            "the standard token trace")

    (options, args) = parser.parse_args()

    if len(args) != 2:
        parser.error("Must specify both the rlis and trace file names")
    (rlis_file, trace_file) = args

    # Read in the packets and make list of bitlog packets
    if options.mode == "network":
        packet_class = packet.AMPacket
    elif options.mode == "system":
        packet_class = packet.SystemPacket
    else:
        parser.error("option -m must be either network or system")
    packets = packet.read_packets(trace_file, packet_class)
    bitlog_packets = packet.BitlogPacket.get_bitlog_packets(packets)

    # Create a source trace from the packets
    bitlog_traces = packetTrace.SourceTrace(bitlog_packets)

    # Load the token table and the parser
    token_table = rlisTokens.TokenTable(rlis_file)
    roi_parser = parseLog.RoiParser(token_table)

    # Tokenize the stream for each node
    node_tokens = {}
    start_time = bitlog_traces.get_start_time()
    for trace_id in sorted(bitlog_traces.traces.keys()):
        trace = bitlog_traces.traces[trace_id]
        tokens_and_times = roi_parser.tokenize_trace(trace, start_time)
        [tokens, times] = zip(*tokens_and_times)
        node_tokens[trace_id] = tokens


    for id in sorted(node_tokens.keys()):

        # If node_id is specified then skip non-node_id nodes
        if options.node_id and id != options.node_id: pass

        # Print the output
        if not options.verbose:
            print " ".join(serialize_tokens(id, node_tokens[id]))
        else:
            print print_tokens(id, node_tokens[id])


if __name__ == '__main__':
    main()
