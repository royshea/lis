#!/usr/bin/env python

from optparse import OptionParser
import rlisTokens
import packet
import packetTrace
import chunkStream
import parseLog
import tree

def make_call_graph(tokens):
    root = tree.CallTree("root")

    node = root
    counter = 0
    for token in tokens:

        # Examine token to see if it is:
        # - None indicating missing data.  Need to continue next
        #   building tree using next token from the root.
        # - Tuple indicating a watch token with data.  Need to separate
        #   out the two pieces of information.
        # - Normal case is just a token.
        if not token:
            node = root
            continue
        elif type(token) == tuple:
            # TODO: Badness to deal with possible tuple generated by
            # the watch token type.
            data = token[1]
            token = token[0]

        # Add the token to the tree!
        if token.type == rlisTokens.RlisEntry.FOOTER:
            node = node.get_parent()

        elif token.type == rlisTokens.RlisEntry.HEADER:
            counter += 1
            node = node.add_child(token.function_name + "_" + str(counter))

        elif token.type == rlisTokens.RlisEntry.CALL:
            counter += 1
            node = node.add_child(token.function_name + "_" + str(counter))

        elif token.type == rlisTokens.RlisEntry.CONDITIONAL:
            ignore = node.add_child('"Branch: %d %s"' % (token.id,
                    counter))

        elif token.type == rlisTokens.RlisEntry.WATCH:
            ignore = node.add_child('"Watch for %s with %d s"' % (token.id, counter))

        else:
            counter += 1
            ignore = node.add_child('"Unknown token"' + " " + str(counter))

    return root


def main():

    # Handle the command line
    usage = "usage: %prog [options] rlis trace"
    parser = OptionParser(usage)

    parser.add_option("-m", "--mode", dest="mode", metavar="STRING",
            default="network", help="Specify the trace mode that " +
            "may be either network or system [default: %default]")

    (options, args) = parser.parse_args()

    if len(args) != 2:
        parser.error("Must specify both the rlis and trace file names")
    (rlis_file, trace_file) = args

    # Load the token table and the parser
    token_table = rlisTokens.TokenTable(rlis_file)
    roi_parser = parseLog.RoiParser(token_table)

    # Read in the packets and make list of bitlog packets
    if options.mode == "network":
        packet_class = packet.AMPacket
    elif options.mode == "system":
        packet_class = packet.SystemPacket
    else:
        parser.error("option -m must be either network or system")
    packets = packet.read_packets(trace_file, packet_class)
    bitlog_packets = packet.BitlogPacket.get_bitlog_packets(packets)

    # Create a source trace from the packets
    bitlog_traces = packetTrace.SourceTrace(bitlog_packets)

    # Print tokens
    start_time = bitlog_traces.traces[0][0].timestamp
    for trace_id in sorted(bitlog_traces.traces.keys()):
        print "# ==== Trace for node %d ====" % (trace_id)
        trace = bitlog_traces.traces[trace_id]
        tokens_and_times = roi_parser.tokenize_trace(trace, start_time)
        [tokens, times] = zip(*tokens_and_times)
        root = make_call_graph(tokens)
        print root

if __name__ == '__main__':
    main()
