Log Instrumentation Specifications (LIS)
=======================================

Overview
--------

[NOTE]
=========

This documentation is a work in progress (June 2008).  Two
tarballs are available while this document is under construction.  The
first is a copy of LIS that has full TinyOS integration.  The second is
a tarball of just the LIS core for use on desktop systems.

* link:lis-tinyos.tgz[LIS for TinyOS]

* link:lis-core.tgz[LIS Core]
========

What is LIS?
~~~~~~~~~~~~

The log instrumentation specification (LIS) language provides a simple
and powerful means to describe data you want to gather from a system at
runtime.  

Users can quickly write a LIS script to accomplish basic logging tasks.
Higher level analyses that provide specialized logging functionality
also use LIS as an intermediate language to direct insertion of logs
into a code base.

LIS is optimized to provide logs using minimal system resources, ranging
from log bandwidth minimization to occupying a small runtime footprint.
This makes LIS a great tool for diagnosing problems and exploring
runtime behavior in resource constrained embedded systems.

LIS does not allow completely free form logging.  Rather, it logs a
stream of markers triggered when a program passes a point of interest
described in a LIS script and potentially a variable value (for watch
points).  This restricted logging framework helps users to formalize
their logging tasks and makes for a lean instrumentation engine and
runtime.


Why use LIS?
~~~~~~~~~~~~

Unlike +printf+ and similar logging systems that require manual system
instrumentation, the LIS script is used at compile time to automate
instrumentation of a code base.  This saves programmer time and effort,
prevents copy and paste errors common to manual log insertion, and makes
it trivial to remove logging after a problem or question has been
resolved.

In some execution domains traditional debugging methods are unwieldy or
simply unavailable.  For example, physical access to a deployed wireless
embedded device often inhibits the use of JTAG or delays caused by
interactive debuggers can mask and create new runtime errors in systems
of interacting devices.

LIS has been used to debug programs and look deeply into the runtime
behavior of both desktop and embedded systems.  It has been used to
examine:

* Standard C programs running on x86 processors

* Distributed embedded software running on the ATMega128  processor

* Distributed embedded software running on the MSP430 processor


What do I need to use LIS?
~~~~~~~~~~~~~~~~~~~~~~~~~~

The LIS framework is designed to instrument C programs.  Other
languages, such as nesC, that compile to C at an intermediate step can
also be handled by the LIS framework.  LIS depends on the following
additional tools:

* http://manju.cs.berkeley.edu/cil/[CIL] which is built using
http://caml.inria.fr/[OCaml] to instrument the programs

* http://www.python.org/doc/[Python] for log parsing and used by some of
the analyses in the distribution that use LIS as an intermediary
language

* The actual LIS distribution is available as a tarball or (for the
latest and greatest) via http://git-scm.com/[git]

* Good 'ol ANSI C for runtime logging support and compiling C programs



Installation
-------------

Installation has been automated using the following installation script:

link:install.sh[LIS Installation Script]

The script requires that OCaml already be installed on the system.  The
script automates:

* Downloading CIL

* Downloading LIS

* Building three versions of CIL for the native (probably x86), avr, and
msp430 processors

* Building three versions of LIS for the native (probably x86), avr, and
msp430 processors

The installation script takes as input a base directory where you want
CIL an LIS to be installed.  For example:

----
wget http://projects.nesl.ucla.edu/~roy/lis/install.sh
sh install.sh $HOME/local
----

This will create a +cil+ and +lis+ directory in +$HOME/local+ to house
the CIL and LIS files respectively.  Take a look at the +install.sh+
script to see what is happening under the covers and for guidance if you
want to manually install LIS.  If you run into any problems with the
installation script please email mailto:royshea@gmail.com[Roy Shea].


Using LIS
---------

The standard LIS work flow includes five stages.

1. *LIS Script Composition*: In the first step the user writes a LIS
script or generates a LIS script using a higher level analysis.

2. *Program Instrumentation*: The LIS instrumentation engine then uses
this script to drive instrumentation of a user program.

3. *Building the Instrumented Program*: An instrumented version of the
program is produced by the instrumentation engine.  If logging support
was not included in the original program, then the instrumented program
should be linked to logging library at build time.

4. *Executing the Program*: The built program is now ready to run.  Logs
produced from program execution can be collected for later analysis.

5. *Log Parsing*: The LIS distribution includes a tokenizer that
tokenizes logs and a parser that pretty prints the stream of log tokens.
The parsing framework is designed for capturing a broad class of call
traces and can be adapted to other logging tasks.


LIS Script Composition
~~~~~~~~~~~~~~~~~~~~~~

A LIS script contains one or more statements.  Each statement specifies
one of five log placement types and what part of the problem the
statement should be applied to.  

All statement include a _placement_ and _scope_ specifier.  The
_placement_ specifier is the name of the function that the statement
should be applied to.  The _scope_ specifier describes the name space
from which the logged token should be taken and can be one of +global+,
+local+, or +point+.  Token scoping is described in more detail below.


The five statement types and their syntax are:

Header
^^^^^^

Syntax::
  +header+ _placement_ _scope_
Description::
  Log a token taken from _scope_ when _placement_ is entered.

Syntax::
  +footer+ _placement_ _scope_
Description::
  Log a token taken from _scope_ when returning from _placement_.

Syntax::
 +call+ _placement_ _scope_ _target_
Description::
 Log a token taken from _scope_ when _placement_ calls into _target_.

Syntax::
 +conditional+ _placement_ _scope_ _flag_ _var_
Description::
 Log a token taken from _scope_ describing the branch taken by control
 flow statement of type _flag_ and guarded by an expression using the
 variable _var_ within _placement_.  The _flag_ is an ORed set of: 1
 +if-else+ statements, 2 +switch-case+ statements or 4 loop constructs.
 Thus, a flag value of 5 will log loop constructs and +if-else+
 statements, but not +switch-case+ statements.  If filtering on _var_ is
 not desired, the special +__NULL__+ token (two leading and trailing
 underscores) can be used.

Syntax::
 +watch+ _placement_ _scope_ _var_
Description::
 Log a token taken from _scope_ followed by the value of _var_ each time
 that _var_ appears as an l-value in function _placement_.



Weaving LIS into a Program
~~~~~~~~~~~~~~~~~~~~~~~~~~

(Name spaces)

TODO


Collecting runtime logs
~~~~~~~~~~~~~~~~~~~~~~~

TODO

Viewing logs
~~~~~~~~~~~~

TODO

Integration into TinyOS
-----------------------

TODO
