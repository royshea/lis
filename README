Log Instrumentation Specifications (LIS)
=======================================

Overview
--------

[NOTE]
=========

This documentation is a work in progress (June 2009).  Two
tarballs are available while this document is under construction.  The
first is a copy of LIS that has full TinyOS integration.  The second is
a tarball of just the LIS core for use on desktop systems.

* link:lis-tinyos.tgz[LIS for TinyOS]

* link:lis-core.tgz[LIS Core]
========

What is LIS?
~~~~~~~~~~~~

The log instrumentation specification (LIS) language provides a simple
and powerful means to describe data you want to gather from a system at
runtime.  

Users can quickly write a LIS script to accomplish basic logging tasks.
Higher level analyses that provide specialized logging functionality
also use LIS as an intermediate language to direct insertion of logs
into a code base.

LIS is optimized to provide logs using minimal system resources, ranging
from log bandwidth minimization to occupying a small runtime footprint.
This makes LIS a great tool for diagnosing problems and exploring
runtime behavior in resource constrained embedded systems.

LIS does not allow completely free form logging.  Rather, it logs a
stream of markers triggered when a program passes a point of interest
described in a LIS script and potentially a variable value (for watch
points).  This restricted logging framework helps users to formalize
their logging tasks and makes for a lean instrumentation engine and
runtime.


Why use LIS?
~~~~~~~~~~~~

Unlike +printf+ and similar logging systems that require manual system
instrumentation, the LIS script is used at compile time to automate
instrumentation of a code base.  This saves programmer time and effort,
prevents copy and paste errors common to manual log insertion, and makes
it trivial to remove logging after a problem or question has been
resolved.

In some execution domains traditional debugging methods are unwieldy or
simply unavailable.  For example, physical access to a deployed wireless
embedded device often inhibits the use of JTAG or delays caused by
interactive debuggers can mask and create new runtime errors in systems
of interacting devices.

LIS has been used to debug programs and look deeply into the runtime
behavior of both desktop and embedded systems.  It has been used to
examine:

* Standard C programs running on x86 processors

* Distributed embedded software running on the ATMega128  processor

* Distributed embedded software running on the MSP430 processor


What do I need to use LIS?
~~~~~~~~~~~~~~~~~~~~~~~~~~

The LIS framework is designed to instrument C programs.  Other
languages, such as nesC, that compile to C at an intermediate step can
also be handled by the LIS framework.  LIS depends on the following
additional tools:

* http://manju.cs.berkeley.edu/cil/[CIL] which is built using
http://caml.inria.fr/[OCaml] to instrument the programs

* http://www.python.org/doc/[Python] for log parsing and used by some of
the analyses in the distribution that use LIS as an intermediary
language

* The actual LIS distribution is available as a tarball or (for the
latest and greatest) via http://git-scm.com/[git]

* Good 'ol ANSI C for runtime logging support and compiling C programs



Installation
-------------

Installation has been automated using the following installation script:

link:install/install.sh[LIS Installation Script]

The script requires that OCaml already be installed on the system.  The
script automates:

* Downloading CIL

* Downloading LIS

* Building three versions of CIL for the native (probably x86), avr, and
msp430 processors

* Building three versions of LIS for the native (probably x86), avr, and
msp430 processors

The installation script takes as input a base directory where you want
CIL an LIS to be installed.  For example:

----
wget http://projects.nesl.ucla.edu/~roy/lis/install/install.sh
sh install.sh $HOME/local
----

This will create a +cil+ and +lis+ directory in +$HOME/local+ to house
the CIL and LIS files respectively.  Take a look at the +install.sh+
script to see what is happening under the covers and for guidance if you
want to manually install LIS.  If you run into any problems with the
installation script please email mailto:royshea@gmail.com[Roy Shea].


Using LIS
---------

The standard LIS work flow includes five stages.

1. *LIS Script Composition*: In the first step the user writes a LIS
script or generates a LIS script using a higher level analysis.

2. *Program Instrumentation*: The LIS instrumentation engine then uses
this script to drive instrumentation of a user program.

3. *Building the Instrumented Program*: An instrumented version of the
program is produced by the instrumentation engine.  If logging support
was not included in the original program, then the instrumented program
should be linked to logging library at build time.

4. *Executing the Program*: The built program is now ready to run.  Logs
produced from program execution can be collected for later analysis.

5. *Log Parsing*: The LIS distribution includes a tokenizer that
tokenizes logs and a parser that pretty prints the stream of log tokens.
The parsing framework is designed for capturing a broad class of call
traces and can be adapted to other logging tasks.


LIS Script Composition
~~~~~~~~~~~~~~~~~~~~~~

A LIS script contains one or more statements.  Each statement specifies
one of five log placement types and what part of the problem the
statement should be applied to.  

All statement include a _placement_ and _scope_ specifier.  The
_placement_ specifier is the name of the function that the statement
should be applied to.  The _scope_ specifier describes the name space
from which the logged token should be taken and can be one of +global+,
+local+, or +point+.  Token scoping is described in more detail below.


The five statement types and their syntax are:

Header
++++++

+header+ _placement_ _scope_

Log a token taken from _scope_ when _placement_ is entered.

Footer
++++++

+footer+ _placement_ _scope_
  
Log a token taken from _scope_ when returning from _placement_.

Call
++++

+call+ _placement_ _scope_ _target_
 
Log a token taken from _scope_ when _placement_ calls into _target_.

Conditional
+++++++++++

+conditional+ _placement_ _scope_ _flag_ _var_
 
Log a token taken from _scope_ describing the branch taken by control
flow statement of type _flag_ and guarded by an expression using the
variable _var_ within _placement_.  The _flag_ is an ORed set of: 1
+if-else+ statements, 2 +switch-case+ statements or 4 loop constructs.
Thus, a flag value of 5 will log loop constructs and +if-else+
statements, but not +switch-case+ statements.  If filtering on _var_ is
not desired, the special +__NULL__+ token (two leading and trailing
underscores) can be used.

Watch
+++++

+watch+ _placement_ _scope_ _var_
 
Log a token taken from _scope_ followed by the value of _var_ each time
that _var_ appears as an l-value in function _placement_.



Weaving LIS into a Program
~~~~~~~~~~~~~~~~~~~~~~~~~~

A LIS script drives instrumentation of a program using the +lis+
program.  The +lis+ program takes as input a preprocessed program and
the LIS script, and produces as output an instrumented program and
optionally the resolved LIS (RLIS) scritp.  The instrumentation engine
inserts calls to a holder function that can be replaced with the system
specific logging function using +sed+.

----
# Create test.c an test.lis files
vim test.c test.lis 

# Instrument program
cpp test.c test.i
lis --lis test.lis --rlis test.rlis --out test.lis.c

# Replace holder function with libbitlog logging
sed -e '/extern void HOLDER_FUNC(char const   \*msg ) ;/d' < test.lis.c > test.bitlog.tmp
sed -e 's/HOLDER_FUNC("\(.*\) \(.*\)");/bitlog_write_data(\1, \2);/' < test.bitlog.tmp > test.bitlog.c

# If the bitlog library was not already used in test.c, the user will
# need to manually include the bitlog.h header file and initialize the
# bitlog library
----

This instrumentation procedure is mostly automated through the
+Makefile.lis+ from the core LIS distribution in conjunction with a
projects current build system.

The output RLIS script is simply the original LIS script along with
resolved token identifiers that will be logged at runtime.  Token
identifiers are assigned by the instrumentation engine using the
following strategy:

Global Scoping::
    Token value unique among all LIS tokens.

Local Scoping::
    Token value unique within the host function. Token value
may appear in local name spaces for other functions.

Point Scoping:: 
    Single unique token value (all point tokens have the same value).


Collecting runtime logs
~~~~~~~~~~~~~~~~~~~~~~~

Collection of runtime logs is specific to the underlying log management
software running on the system.  The LIS core includes a simple demo
application that uses the included +sendlog.c+ to print log data out
over standard out.  These can simply be redirected into a file for
analysis:

----
./demo_lis 2> log.txt
----

Viewing logs
~~~~~~~~~~~~

The LIS parsers is able to parse a wide collection of logs.  It takes as
input a log file and the associated RLIS script.  It uses this
information to parse the log and produce a formatted output of runtime
tokens encountered in from the trace.

----
parseLog.py -r test.rlis -f system -t log.txt
----


Integration into TinyOS
-----------------------

LIS was specifically developed for collecting data from resource
constrained wireless embedded systems.  We have provided full
integration with the TinyOS 2.x operating system.  This support
provides:

* Build integration via a new "lis" option as an add-on to the mica2,
micaZ and TelosB targets

* Low overhead +bitlog+ runtime library providing basic logging support

* Multi-hop log delivery using the
http://www.tinyos.net/tinyos-2.1.0/doc/html/tep123.html[collection tree
protocol]

* Single-hop log delivery using the +AMSend+ interface

The following installation script will download a clean version of
TinyOS and integrate LIS support into it.

link:install/tos_install.sh[TinyOS Installation Script]

The installation script takes as input a base directory describing where
you installed LIS and a base directory where you want to install TinyOS.

----
wget http://projects.nesl.ucla.edu/~roy/lis/install/tos_install.sh
sh tos_install.sh $HOME/local/ $HOME/local
----

The TinyOS support can be accessed via one of two modes: directly via
LIS scripts or using a higher level analysis that implements optimized
call trace generation.

----
# Move into demo directory
cd apps/MultihopLogTapRadioCountToLeds

# Generate image instrumented based on the "health_no_crc.lis" script
LIS_FILE=health_no_crc.lis make telosb lis

# Generate image that gathers call traces through the LedsP and
# CtpRoutingEngineP TinyOS components.
LOG_PREFIX="LedsP CtpRoutingEngineP" make telosb lowlog
----

